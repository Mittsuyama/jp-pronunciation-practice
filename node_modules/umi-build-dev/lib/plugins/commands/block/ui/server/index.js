"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function _fs() {
  const data = require("fs");

  _fs = function _fs() {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function _path() {
    return data;
  };

  return data;
}

var _clearGitCache = _interopRequireDefault(require("../../clearGitCache"));

var _Block = _interopRequireDefault(require("./core/Block"));

var _util = require("./util");

var _haveRootBinding = _interopRequireDefault(require("../../sdk/haveRootBinding"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _default = api => {
  const blockService = new _Block.default(api); // åŒºå—åˆ—è¡¨ç¼“å­˜

  const blockListCache = {};
  api.onUISocket(
  /*#__PURE__*/
  function () {
    var _ref = _asyncToGenerator(function* ({
      action,
      failure,
      success,
      send
    }) {
      blockService.init(send);
      const type = action.type,
            _action$payload = action.payload,
            payload = _action$payload === void 0 ? {} : _action$payload,
            lang = action.lang; // åŒºå—èµ„æºå¯é…ç½®

      let resources = [];
      resources = api.applyPlugins('addBlockUIResource', {
        initialValue: _util.DEFAULT_RESOURCES
      });
      resources = api.applyPlugins('modifyBlockUIResources', {
        initialValue: resources
      });

      switch (type) {
        // è·å¾—é¡¹ç›®çš„è·¯ç”±
        case 'org.umi.block.routes':
          _asyncToGenerator(function* () {
            try {
              const routers = blockService.depthRouterConfig();
              success({
                data: routers,
                success: true
              });
            } catch (error) {
              failure({
                message: error.message,
                success: false
              });
            }
          })();

          break;
        // è·å¾—é¡¹ç›® page ä¸‹çš„ç›®å½•ç»“æ„

        case 'org.umi.block.pageFolders':
          _asyncToGenerator(function* () {
            try {
              success({
                data: blockService.getFolderTreeData(),
                success: true
              });
            } catch (error) {
              failure({
                message: error.message,
                success: false
              });
            }
          })();

          break;
        // è·å¾—é¡¹ç›®çš„è·¯ç”±é…ç½®å’Œé»˜è®¤çš„ç»„ä»¶

        case 'org.umi.block.routeFiles':
          _asyncToGenerator(function* () {
            try {
              success({
                data: blockService.depthRouteComponentConfig(),
                success: true
              });
            } catch (error) {
              failure({
                message: error.message,
                success: false
              });
            }
          })();

          break;
        // æ¸…ç©ºç¼“å­˜

        case 'org.umi.block.clear':
          _asyncToGenerator(function* () {
            try {
              const info = (0, _clearGitCache.default)(payload, api);
              success({
                data: info,
                success: true
              });
            } catch (error) {
              failure({
                message: error.message,
                success: false
              });
            }
          })();

          break;
        // åŒºå—è·å¾—æ•°æ®æº

        case 'org.umi.block.resource':
          success({
            data: resources,
            success: true
          });
          break;
        // è·å–åŒºå—åˆ—è¡¨

        case 'org.umi.block.list':
          _asyncToGenerator(function* () {
            try {
              const _ref7 = payload,
                    resourceId = _ref7.resourceId;
              let data = blockListCache[resourceId];

              if (!data || payload.force) {
                data = yield blockService.getBlockList(resourceId, resources);
                blockListCache[resourceId] = data;
              }

              success({
                data,
                success: true
              });
            } catch (error) {
              failure({
                message: error.message,
                success: false
              });
            }
          })();

          break;
        // è·å–å®‰è£…ä¸­çš„æ—¥å¿—

        case 'org.umi.block.get-adding-blocks-log':
          success({
            data: blockService.getLog(),
            success: true
          });
          break;
        // è·å–å®‰è£…ä¸­åŒºå— url

        case 'org.umi.block.get-adding-block-url':
          success({
            data: blockService.getBlockUrl(),
            success: true
          });
          break;
        // å–æ¶ˆä»»åŠ¡

        case 'org.umi.block.cancel':
          success({
            data: blockService.cancel(),
            success: true
          });
          break;
        // å–æ¶ˆä»»åŠ¡

        case 'org.umi.block.retry':
          success({
            data: blockService.retry(_objectSpread({}, payload)),
            success: true
          });
          break;
        // åŒºå—æ·»åŠ 

        case 'org.umi.block.add':
          _asyncToGenerator(function* () {
            const _ref9 = payload,
                  url = _ref9.url; // æ‰§è¡Œé€»è¾‘

            try {
              yield blockService.run(_objectSpread({}, payload));
              success({
                data: {
                  message: `ğŸŠ ${url} block is adding`
                },
                success: true
              });
            } catch (error) {
              failure({
                message: error.message,
                success: false
              });
            }
          })();

          break;

        case 'org.umi.block.checkIfCanAdd':
          _asyncToGenerator(function* () {
            const _ref11 = payload,
                  item = _ref11.item;
            /**
             * è·å–config ä¸­ react çš„åˆ¤æ–­
             * @param reactPlugin   reactPlugin<any>
             */

            function genReactPluginOpts(reactPlugin) {
              if (reactPlugin && typeof reactPlugin !== 'string') {
                return reactPlugin[1];
              }

              return {};
            }
            /**
             * æ˜¯ä¸æ˜¯æœ‰è¿™ä¸ª feature tag
             * @param feature
             */


            function haveFeature(feature) {
              return item.features && item.features.includes(feature);
            }

            if (!api.config.routes) {
              failure({
                message: lang === 'zh-CN' ? 'åŒºå—æ·»åŠ æš‚ä¸æ”¯æŒçº¦å®šå¼è·¯ç”±ï¼Œè¯·å…ˆè½¬æˆé…ç½®å¼è·¯ç”±ã€‚' : 'The block adding does not support the conventional route, please convert to a configuration route.'
              });
              return;
            }

            const payloadType = payload.type === 'block' ? 'åŒºå—' : 'æ¨¡æ¿';
            const isBigfish = !!process.env.BIGFISH_COMPAT;
            const reactPlugin = (api.config.plugins || []).find(p => {
              return p === 'umi-plugin-react' || p[0] === 'umi-plugin-react';
            });
            const reactPluginOpts = genReactPluginOpts(reactPlugin); // æå‰åˆ¤æ–­æ˜¯å¦æœ‰ package.jsonï¼ŒåŒºå—æ·»åŠ æ—¶å¦‚æœæ²¡æœ‰ä¼šæŠ¥é”™

            if (!(0, _fs().existsSync)((0, _path().join)(api.cwd, 'package.json'))) {
              failure({
                message: lang === 'zh-CN' ? `${payloadType}æ·»åŠ éœ€è¦åœ¨é¡¹ç›®æ ¹ç›®å½•æœ‰ package.json` : `package.json is required to add ${payloadType}`
              });
              return;
            } // antd ç‰¹æ€§ä¾èµ–
            // bigfish é»˜è®¤å¼€äº† antd
            // if (haveFeature('antd') && !isBigfish) {
            //   if (!reactPlugin || !reactPluginOpts.antd) {
            //     failure({
            //       message:
            //         lang === 'zh-CN'
            //           ? `${payloadType}ä¾èµ– antdï¼Œè¯·å®‰è£… umi-plugin-react æ’ä»¶å¹¶å¼€å¯ antd ã€‚`
            //           : 'Block depends on antd, please install umi-plugin-react and enable antd.',
            //     });
            //     return;
            //   }
            // }
            // dva ç‰¹æ€§ä¾èµ–


            if (haveFeature('dva')) {
              if (isBigfish) {
                if (api.config.dva === false) {
                  failure({
                    message: `${payloadType}ä¾èµ– dvaï¼Œè¯·å¼€å¯ dva é…ç½®ã€‚`
                  });
                  return;
                }
              } else if (!reactPlugin || !reactPluginOpts.dva) {
                failure({
                  message: lang === 'zh-CN' ? `${payloadType}ä¾èµ– dvaï¼Œè¯·å®‰è£… umi-plugin-react æ’ä»¶å¹¶å¼€å¯ dva ã€‚` : 'Block depends on dva, please install umi-plugin-react and enable dva.'
                });
                return;
              }
            } // locale ç‰¹æ€§ä¾èµ–


            if (haveFeature('i18n')) {
              if (isBigfish) {
                if (!api.config.locale) {
                  failure({
                    message: `${payloadType}ä¾èµ– localeï¼Œè¯·å¼€å¯ locale é…ç½®ã€‚`
                  });
                  return;
                }
              }

              if (!reactPlugin || !reactPluginOpts.locale) {
                failure({
                  message: lang === 'zh-CN' ? `${payloadType}ä¾èµ–å›½é™…åŒ–ï¼ˆi18nï¼‰ï¼Œè¯·å®‰è£… umi-plugin-react æ’ä»¶å¹¶å¼€å¯ locale ã€‚` : 'Block depends on i18n, please install umi-plugin-react and enable locale.'
                });
                return;
              }
            }

            success({
              data: true,
              success: true
            });
          })();

          break;
        // æ£€æŸ¥è·¯ç”±æ˜¯å¦å­˜åœ¨

        case 'org.umi.block.checkExistRoute':
          const _ref12 = payload,
                path = _ref12.path;
          success({
            exists: blockService.routeExists(path),
            success: true
          });
          break;
        // æ£€æŸ¥æ–‡ä»¶è·¯å¾„æ˜¯å¦å­˜åœ¨

        case 'org.umi.block.checkExistFilePath':
          try {
            const _ref13 = payload,
                  blockPath = _ref13.path; // æ‹¼æ¥çœŸå®çš„è·¯å¾„ï¼Œåº”è¯¥æ˜¯é¡¹ç›®çš„ pages ç›®å½•ä¸‹

            const absPath = api.winPath((0, _path().join)(api.paths.absPagesPath, blockPath));
            success({
              exists: (0, _fs().existsSync)(absPath),
              success: true
            });
          } catch (error) {
            failure({
              message: error.message,
              success: false
            });
          }

          break;
        // æ£€æŸ¥æ–‡ä»¶é‡Œä½¿ç”¨æŸä¸ªå˜é‡åæ˜¯å¦å¯ä»¥

        case 'org.umi.block.checkBindingInFile':
          _asyncToGenerator(function* () {
            try {
              const _ref15 = payload,
                    targetPath = _ref15.path,
                    name = _ref15.name; // æ‰¾åˆ°å…·ä½“çš„ js

              const absTargetPath = api.winPath((0, _path().join)(api.paths.absPagesPath, api.winPath(targetPath).replace(api.winPath(api.paths.pagesPath), ''))); // æœ‰äº›ç”¨æˆ·è·¯ç”±ä¸‹è½½è·¯å¾„æ˜¯ä¸åœ¨çš„ï¼Œè¿™é‡Œæ‹¦ä½ä»–ä»¬

              if (!(0, _fs().existsSync)(absTargetPath)) {
                failure({
                  message: ` ${absTargetPath} ç›®å½•ä¸å­˜åœ¨!`,
                  success: false
                });
                return;
              }

              const entryPath = api.findJS(absTargetPath, 'index') || api.findJS(absTargetPath, '');

              if (!entryPath) {
                failure({
                  message: `æœªåœ¨ ${absTargetPath} ç›®å½•ä¸‹æ‰¾åˆ° index.(ts|tsx|js|jsx) !`,
                  success: false
                });
                return;
              }

              (0, _haveRootBinding.default)((0, _fs().readFileSync)(entryPath, 'utf-8'), name).then(exists => {
                success({
                  exists,
                  success: true
                });
              });
            } catch (error) {
              failure({
                message: error.message,
                success: false
              });
            }
          })();

          break;

        /**
         *  C:\GitHub\ant-design-pro\src\pages\Welcome\index.tsx
         * --->
         *   Welcome\index.tsx
         *  ç”¨ä¸å°†è·¯å¾„å˜åŒ–ä¸ºç›¸å¯¹è·¯å¾„
         *  */

        case 'org.umi.block.getRelativePagesPath':
          _asyncToGenerator(function* () {
            const _ref17 = payload,
                  targetPath = _ref17.path;
            success({
              data: api.winPath(targetPath).replace(api.winPath(api.cwd), '').replace(api.winPath(api.paths.pagesPath), '').replace(/\//g, '/').replace(/\/\//g, '/'),
              success: true
            });
          })();

          break;

        default:
          break;
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());
};

exports.default = _default;